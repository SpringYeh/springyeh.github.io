<!DOCTYPE html>
<html lang="zh"><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content=""><title>1099 Build A Binary Search Tree - 学而时习之 | 一叶知秋</title><script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?f5d6cbe800b85fe8f7d5f2a9a9fb22d6";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>
  <meta name="keywords" content="一叶知秋, 原创博客,生活, cinzano, Jekyll, blog">
  <meta name="description" content="一叶知秋|日常|PAT|书|少女与猫|诗词集"><link rel="stylesheet" href="https://at.alicdn.com/t/font_1572012_xhxate8uig.css">
<link rel="stylesheet" href="/assets/main.css?v=0.1.7" />
<link rel="stylesheet" href="/assets/css/custom.css" />

<script src="/assets/js/main.js?v=0.1.7" defer></script>
<script src="https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script><!-- 原样式 -->
<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/monokai-sublime.min.css" />
<script src="/assets/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
	    MathJax.Hub.Config({
	      tex2jax: {
	        inlineMath: [['$','$'], ['\\(','\\)']],
	      }
	    });
	</script><script src="https://unpkg.com/mermaid@7.1.0/dist/mermaid.min.js" defer></script></head>

<body class="body-chapter">
	<script>
	if('学而时习之'== '诗'){
		$('body').addClass("poem-page");
		// console.log( '学而时习之' );
	}else if('学而时习之'== '万事集'){
		$('body').addClass("tale-page");
		// console.log( '学而时习之' );
	}
</script>

<div class="book__wrapper sidebar-right" id="bookMain"><div class="book-summary" id="bookSummary">
  <nav role="navigation">
    <ul class="summary">
      <li class="chapter ">
        <a href="/learn/" class="custom-link">学而时习之</a>
      </li>
      <li class="divider"></li><li class="chapter "><a href="/learn/pat-A.html">PAT 甲级</a><ul class="articles"><li class="chapter ">
            <a href="/learn/A1001.html">1001 A+B Format</a>
          </li><li class="chapter ">
            <a href="/learn/A1042.html">1042 Shuffling Machine</a>
          </li><li class="chapter ">
            <a href="/learn/A1063.html">1063 Set Similarity</a>
          </li><li class="chapter ">
            <a href="/learn/A1064.html">1064 Complete Binary Search Tree</a>
          </li><li class="chapter active">
            <a href="/learn/A1099.html">1099 Build A Binary Search Tree</a>
          </li></ul></li></ul>
  </nav>
</div>
<div class="book__body">
    <div class="body__inner"><a href="/" class="logo"><img src="/assets/img/logo.svg" class="logo_img"><h1>一叶知秋</h1>
</a><a href="/archive.html" class="sidebar__toggler">
  <span class="sidebar__toggler_top"></span>
  <span class="sidebar__toggler_middle"></span>
  <span class="sidebar__toggler_bottom"></span>
</a><div class="book-header" role="navigation">
    <a href="#" id="summaryToggler" class="summary__toggler">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="12" r="1"></circle>
  <circle cx="19" cy="12" r="1"></circle>
  <circle cx="5" cy="12" r="1"></circle>
</svg>

    </a>
<!--   <h1>
    1099 Build A Binary Search Tree - 学而时习之
  </h1> -->
</div><main class="chapter__wrapper" tabindex="-1" role="main">
        <div class="chapter__inner">
          <article class="chapter__content content">
            <h1 id="a1099-build-a-binary-search-tree-30-分">A1099. Build A Binary Search Tree (30 分)</h1>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>

<p>The left subtree of a node contains only nodes with keys less than the node’s key.
The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.
Both the left and right subtrees must also be binary search trees.
Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.</p>

<p><img src="https://images.ptausercontent.com/24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg" alt="A1099"></p>

<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format <strong>left_index right_index</strong>, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line.</p>

<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.</p>

<h3 id="sample-input">Sample Input:</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>9
1 6
2 3
-1 -1
-1 4
5 -1
-1 -1
7 -1
-1 8
-1 -1
73 45 11 58 82 25 67 38 42
</code></pre></div></div>
<h3 id="sample-output">Sample Output:</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>58 25 82 11 38 67 45 73 42
</code></pre></div></div>
<hr>
<h3 id="题目大意">题目大意：</h3>
<p>同A1064题意相似，这一题是普通的二叉排序树，将给定数据填进构造的树，使其是一棵二叉排序树</p>

<h3 id="分析">分析：</h3>
<p>原理同A1064。采用二叉树静态写法构造树，先将输入数据排序，再对构造的树进行中序遍历，遍历过程按序填入输入数据，最后按层序遍历输出~</p>

<hr>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;map&gt; 
#include&lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span><span class="o">=</span><span class="mi">110</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lchild</span><span class="p">,</span><span class="n">rchild</span><span class="p">;</span>
<span class="p">}</span><span class="n">Node</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">inorder</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>	<span class="k">return</span><span class="p">;</span>
	<span class="n">inorder</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">lchild</span><span class="p">);</span>
	<span class="n">Node</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">];</span>
	<span class="n">inorder</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">rchild</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">levelorder</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="p">){</span>
	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
		<span class="kt">int</span> <span class="n">now</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">lchild</span><span class="o">!=-</span><span class="mi">1</span><span class="p">){</span>
			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">lchild</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">rchild</span><span class="o">!=-</span><span class="mi">1</span><span class="p">){</span>
			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">rchild</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
		<span class="n">Node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lchild</span><span class="o">=</span><span class="n">l</span><span class="p">;</span>
		<span class="n">Node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rchild</span><span class="o">=</span><span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">data</span><span class="o">+</span><span class="n">n</span><span class="p">);</span>
	<span class="n">inorder</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">levelorder</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>	<span class="n">printf</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

          </article>
        </div><footer class="site-footer">
  © 2021<a href="/">一叶知秋</a>. All rights reserved.
</footer>
</main>
    </div><a href="/learn/A1064.html" class="navigation navigation-prev" aria-label="Previous page: 1064 Complete Binary Search Tree"><svg viewBox="0 0 32 32" width="32" height="32" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
  <path d="M20 30 L8 16 20 2" />
</svg>
</a></div>
</div>
</body>

</html>